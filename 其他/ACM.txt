runtime error （运行时错误）就是程序运行到一半，程序就崩溃了。
比如说：
①除以零
②数组越界：int a[3]; a[10000000]=10;
③指针越界：int * p; p=(int *)malloc(5 * sizeof(int)); *(p+1000000)=10;
④使用已经释放的空间：int * p; p=(int *)malloc(5 * sizeof(int));free(p); *p=10;
⑤数组开得太大，超出了栈的范围，造成栈溢出：int a[100000000]; 


冒泡法排序要注意


malloc函数 动态内存分配 申请一块连续的指定大小的内存区域以void*类型返回分配的内存区域地址   当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存，且分配的大小就是程序要求的大小。
返回值是分配区域的起始地址 这个函数是一个指针型函数，返回的指针指向该分配域的开头位置
一般它需和free函数配对使用。free函数能释放某个动态分配的地址，表明不再使用这块动态分配的内存了，实现把之前动态申请的内存返还给系统。 [1]  

colloc函数 在内存的动态存储区中分配num个长度为size的连续空间，函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。
原型：void* calloc（unsigned int num，unsigned int size）；
功能：在内存的动态存储区中分配num个长度为size的连续空间；
注意：num：对象个数，size：对象占据的内存字节数，相较于malloc函数，calloc函数会自动将内存初始化为0



两者区别：calloc在动态分配完内存后，自动初始化该内存空间为零，而malloc不做初始化，分配到的空间中的数据是随机数据。其中malloc的简介如下：
原型：extern void* malloc(unsigned int size)； [1]  
功能：动态分配内存；
注意：size仅仅为申请内存字节大小，与申请内存块中存储的数据类型无关，故编程时建议通过以下方式给出，"长度 * sizeof(数据类型)"； [2]  




